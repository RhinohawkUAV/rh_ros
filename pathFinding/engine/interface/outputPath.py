import math

from engine.interface.solutionWaypoint import SolutionWaypoint


class OutputPath:
    """
    Represents a path generated by the path finder.  The path may or may not be complete.
    """

    def __init__(self, pathWaypoints, pathSegments, quality, numWayPointsCompleted, estimatedTime):
        self.pathWaypoints = pathWaypoints
        self.pathSegments = pathSegments
        self.numWayPointsCompleted = numWayPointsCompleted
        self.quality = quality
        self.estimatedTime = estimatedTime


def generatePath(endVertex, waypointAcceptanceRadii, quality, numWayPointsCompleted):
    pathSegments = endVertex.generatePathSegments()
    pathWaypoints = _calcSolutionWaypoints(pathSegments, waypointAcceptanceRadii)
    return OutputPath(pathWaypoints, pathSegments, quality, numWayPointsCompleted, endVertex.getTimeThroughHeuristic())


def _calcSolutionWaypoints(pathSegments, waypointAcceptanceRadii):
    solutionWaypoints = []
    for pathSegment in pathSegments:
        
        # We are arcing close to 180 degrees.  To force flight controller to loop in this direction, add waypoint
        if pathSegment.arc.length - math.pi > 0.01:
            (position, direction) = pathSegment.arc.endInfoLength(math.pi - 0.01)
            solutionWaypoints.append(SolutionWaypoint(position, waypointAcceptanceRadii))
        
        position = pathSegment.endPoint + pathSegment.endUnitVelocity * waypointAcceptanceRadii
        solutionWaypoints.append(SolutionWaypoint(position, waypointAcceptanceRadii))
        
    return solutionWaypoints
